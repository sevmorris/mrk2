#!/usr/bin/env bash
set -euo pipefail

# mrk2 installer — Homebrew packages and applications installation

# Check if running on macOS
if [[ "$(uname -s)" != "Darwin" ]]; then
  echo "Error: This script is designed for macOS only." >&2
  echo "Detected OS: $(uname -s)" >&2
  exit 1
fi

NO_CASKS=0
NO_FORMULAE=0
ONLY_FORMULAE=0
DEBUG=0
DRY_RUN=0
SKIP_BREW_INSTALL=0

while (("$#")); do
  case "$1" in
    --no-casks) NO_CASKS=1 ;;
    --no-formulae) NO_FORMULAE=1 ;;
    --only-formulae) ONLY_FORMULAE=1; NO_CASKS=1 ;;
    --skip-brew-install) SKIP_BREW_INSTALL=1 ;;
    --debug) DEBUG=1 ;;
    --dry-run) DRY_RUN=1 ;;
    -h|--help)
      cat <<'USAGE'
mrk2 installer

Usage: scripts/install [options]
  --no-casks            Skip Homebrew cask installation (GUI apps)
  --no-formulae         Skip Homebrew formulae installation (CLI tools)
  --only-formulae       Only install Homebrew formulae (CLI tools)
  --skip-brew-install   Skip Homebrew installation (assume it's already installed)
  --dry-run             Preview changes without applying them
  --debug               Enable bash tracing (set -x)
USAGE
      exit 0
      ;;
    *) echo "Unknown option: $1" >&2; exit 2 ;;
  esac
  shift
done

(( DEBUG )) && set -x

if (( DRY_RUN )); then
  echo "=== DRY RUN MODE: No changes will be made ===" >&2
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
BREWFILE="$REPO_ROOT/Brewfile"
LOGFILE="$HOME/mrk2-install.log"

# Create log directory
if ! mkdir -p "$(dirname "$LOGFILE")"; then
  echo "Error: Failed to create log directory" >&2
  exit 1
fi

log()  { printf "[mrk2] %s\n" "$*" >&2; }
warn() { printf "[warn] %s\n" "$*" >&2; }
err()  { printf "[err ] %s\n" "$*" >&2; }
dry()  { if (( DRY_RUN )); then printf "[dry] %s\n" "$*"; else log "$@"; fi; }

# Setup logging with rotation
setup_logging() {
  local max_size=10485760  # 10MB
  if [[ -f "$LOGFILE" ]] && [[ $(stat -f%z "$LOGFILE" 2>/dev/null || echo 0) -gt $max_size ]]; then
    local rotated="${LOGFILE}.old"
    mv "$LOGFILE" "$rotated" 2>/dev/null || true
    echo "[mrk2] Rotated log file (size exceeded ${max_size} bytes)" >&2
  fi
}

setup_logging
# Redirect output to log, but keep stderr available for prompts
exec > >(tee -a "$LOGFILE")
exec 2> >(tee -a "$LOGFILE" >&2)
log "Starting mrk2 installation... (log: $LOGFILE)"
if (( DRY_RUN )); then
  log "DRY RUN MODE: No changes will be made"
fi

# Track installation statistics
BREW_INSTALLED=0
FORMULAE_INSTALLED=0
CASKS_INSTALLED=0
ERRORS=0
WARNINGS=0

# Check if Homebrew is installed
check_homebrew() {
  if command -v brew >/dev/null 2>&1; then
    log "Homebrew is already installed: $(brew --version | head -n1)"
    return 0
  fi
  return 1
}

# Install Homebrew
install_homebrew() {
  if (( SKIP_BREW_INSTALL )); then
    log "Skipping Homebrew installation (--skip-brew-install flag)"
    if ! check_homebrew; then
      err "Homebrew is not installed and --skip-brew-install was specified"
      return 1
    fi
    return 0
  fi

  if check_homebrew; then
    return 0
  fi

  log "Homebrew not found. Installing Homebrew..."
  if (( DRY_RUN )); then
    dry "Would run: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
    BREW_INSTALLED=1
    return 0
  fi

  if /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
    # Add Homebrew to PATH for Apple Silicon Macs
    if [[ -f /opt/homebrew/bin/brew ]]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -f /usr/local/bin/brew ]]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
    log "Homebrew installed successfully"
    BREW_INSTALLED=1
    return 0
  else
    err "Failed to install Homebrew"
    return 1
  fi
}

# Ensure Homebrew is in PATH
ensure_brew_path() {
  if ! command -v brew >/dev/null 2>&1; then
    if [[ -f /opt/homebrew/bin/brew ]]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -f /usr/local/bin/brew ]]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  fi

  if ! command -v brew >/dev/null 2>&1; then
    err "Homebrew is not in PATH. Please install it manually or restart your shell."
    return 1
  fi
}

# MAS (Mac App Store) support has been removed due to reliability issues

# Read a single keypress, handling escape sequences for arrow keys
# Returns: "UP", "DOWN", "SPACE", "ENTER", or the character pressed
# Note: Terminal should already be in raw mode when this is called
read_key() {
  local key
  
  # Terminal should already be in raw mode from interactive_selection
  # We don't need to change terminal settings here
  
  # Read first character (will timeout after 0.2 seconds)
  # In raw mode, we need to read carefully to avoid blocking
  IFS= read -r -n 1 -t 0.2 key < /dev/tty 2>/dev/null
  local read_status=$?
  
  # If we got escape sequence, read the rest immediately
  if [[ "$key" == $'\033' ]]; then
    # Read the next 2 characters immediately (no timeout in raw mode)
    # We need to read quickly to consume the entire sequence
    local next_char=""
    local dir_char=""
    
    # Try to read '[' with a very short timeout
    if IFS= read -r -n 1 -t 0.05 next_char < /dev/tty 2>/dev/null; then
      if [[ "$next_char" == "[" ]]; then
        # Read the direction character [A-D]
        if IFS= read -r -n 1 -t 0.05 dir_char < /dev/tty 2>/dev/null; then
          case "$dir_char" in
            A) key="UP" ;;
            B) key="DOWN" ;;
            C) key="RIGHT" ;;
            D) key="LEFT" ;;
            *) 
              # Invalid direction, consume and ignore
              key=""
              ;;
          esac
        else
          # Timeout reading direction
          key=""
        fi
      else
        # Not a standard arrow key sequence
        key=""
      fi
    else
      # Timeout reading '['
      key=""
    fi
    
    # Immediately flush any remaining characters in the buffer
    # This is critical - consume everything that might be left
    local flush_attempts=0
    while (( flush_attempts < 50 )); do
      # Use a very short timeout to check for available data
      if ! IFS= read -r -t 0.001 < /dev/tty 2>/dev/null; then
        break
      fi
      # Consume one character immediately
      IFS= read -r -n 1 -t 0.001 < /dev/tty >/dev/null 2>&1 || break
      ((flush_attempts++))
    done
  elif [[ $read_status -ne 0 ]] || [[ -z "$key" ]]; then
    # Timeout or empty, just return empty (terminal stays in raw mode)
    echo -n ""
    return 0
  elif [[ "$key" == " " ]]; then
    key="SPACE"
  elif [[ "$key" == $'\n' ]] || [[ "$key" == $'\r' ]]; then
    # Handle Enter key
    key="ENTER"
  elif [[ "$key" == "q" ]] || [[ "$key" == "Q" ]]; then
    key="QUIT"
  elif [[ "$key" == "a" ]] || [[ "$key" == "A" ]]; then
    key="ALL"
  elif [[ "$key" == "n" ]] || [[ "$key" == "N" ]]; then
    key="NONE"
  elif [[ "$key" == "d" ]] || [[ "$key" == "D" ]]; then
    # Alternative way to finish (d for done)
    key="ENTER"
  fi
  
  # Flush any remaining input to prevent escape sequences from leaking
  # Since terminal is already in raw mode, we just need to consume any buffered input
  local flush_count=0
  while IFS= read -r -t 0 < /dev/tty 2>/dev/null && (( flush_count < 20 )); do
    IFS= read -r -n 1 -t 0.005 < /dev/tty >/dev/null 2>&1 || break
    ((flush_count++))
  done
  
  echo -n "$key"
}

# Interactive selection form for apps with arrow key navigation
# Usage: interactive_selection "cask"|"formula" items_array selected_array
# items_array format: "name|line|id" for each item
# Returns selected items in selected_array (associative array)
interactive_selection() {
  local type="$1"  # "cask" or "formula"
  local -n items="$2"  # array of items: "name|line|id"
  local -n selected="$3"  # associative array: selected[name]=1 if selected
  
  # Only show selection if we have a TTY
  if [[ ! -t 0 ]]; then
    # Non-interactive, select nothing
    return 0
  fi
  
  local total=${#items[@]}
  if (( total == 0 )); then
    return 0
  fi
  
  # Check if terminal supports colors
  local colors_supported=0
  if tput colors >/dev/null 2>&1 && (( $(tput colors 2>/dev/null || echo 0) >= 8 )); then
    colors_supported=1
  fi
  
  # Color definitions (using tput for portability)
  # If colors aren't supported, these will be empty strings
  local color_reset=""
  local color_bold=""
  local color_underline=""
  local color_reverse=""
  local color_white=""
  local color_cyan=""
  local color_green=""
  local color_yellow=""
  local color_blue=""
  local color_magenta=""
  local color_red=""
  local bg_cyan=""
  local bg_blue=""
  local bg_green=""
  
  if (( colors_supported )); then
    color_reset=$(tput sgr0 2>/dev/null || echo "")
    color_bold=$(tput bold 2>/dev/null || echo "")
    color_underline=$(tput smul 2>/dev/null || echo "")
    color_reverse=$(tput rev 2>/dev/null || echo "")
    
    # Colors
    color_white=$(tput setaf 7 2>/dev/null || echo "")
    color_cyan=$(tput setaf 6 2>/dev/null || echo "")
    color_green=$(tput setaf 2 2>/dev/null || echo "")
    color_yellow=$(tput setaf 3 2>/dev/null || echo "")
    color_blue=$(tput setaf 4 2>/dev/null || echo "")
    color_magenta=$(tput setaf 5 2>/dev/null || echo "")
    color_red=$(tput setaf 1 2>/dev/null || echo "")
    
    # Background colors
    bg_cyan=$(tput setab 6 2>/dev/null || echo "")
    bg_blue=$(tput setab 4 2>/dev/null || echo "")
    bg_green=$(tput setab 2 2>/dev/null || echo "")
  fi
  
  # Save terminal state and set up cleanup trap
  local old_stty
  old_stty=$(stty -g 2>/dev/null)
  
  # Set terminal to raw mode for the entire interactive session
  # This prevents escape sequences from appearing and ensures consistent behavior
  # On macOS, we need to be careful with stty settings
  # Disable canonical mode, echo, and all input processing
  stty -icanon -echo -icrnl -opost -isig -ixon -iexten time 0 min 0 < /dev/tty 2>/dev/null || {
    stty "$old_stty" < /dev/tty 2>/dev/null
    return 1
  }
  
  # Double-check echo is off
  stty -echo < /dev/tty 2>/dev/null
  
  # Hide cursor to prevent visual artifacts
  tput civis > /dev/tty 2>/dev/null
  
  # Cleanup function to restore terminal
  cleanup_terminal() {
    # Show cursor again
    tput cnorm > /dev/tty 2>/dev/null
    
    # Flush any remaining input first (very aggressively)
    local flush_count=0
    while IFS= read -r -t 0 < /dev/tty 2>/dev/null && (( flush_count < 100 )); do
      IFS= read -r -n 1 -t 0.001 < /dev/tty >/dev/null 2>&1 || break
      ((flush_count++))
    done
    
    # Restore terminal settings
    if [[ -n "$old_stty" ]]; then
      stty "$old_stty" < /dev/tty 2>/dev/null
    fi
    # Ensure echo is back on
    stty echo < /dev/tty 2>/dev/null
    # Ensure canonical mode is restored
    stty icanon < /dev/tty 2>/dev/null
    # Clear screen
    tput clear > /dev/tty 2>/dev/null || clear > /dev/tty 2>/dev/null
  }
  
  # Trap to ensure terminal is restored on exit
  trap cleanup_terminal EXIT INT TERM
  
  # Handle terminal resize - redraw the screen
  handle_resize() {
    needs_full_redraw=1
    redraw_screen
  }
  trap handle_resize WINCH
  
  # Initialize all as unselected
  local i
  for i in "${!items[@]}"; do
    local item_data="${items[$i]}"
    local name="${item_data%%|*}"
    selected["$name"]=0
  done
  
  # Fixed layout: 4 columns, 20 rows (80 items visible at once)
  local num_cols=4
  local num_rows=20
  local items_per_page=$((num_cols * num_rows))  # 80 items
  
  # Cursor position: column (0-3) and row (0-19) within visible page
  local cursor_col=0
  local cursor_row=0
  local prev_cursor_col=0
  local prev_cursor_row=0
  local page_start=0  # First item index of current page (for scrolling)
  local prev_page_start=0
  local done=0
  local needs_full_redraw=1
  local header_lines=3  # Number of lines before the item list (title + stats + blank)
  
  # Calculate maximum item name length for column width
  # Set a fixed maximum width to prevent wrapping with different window sizes
  local max_name_len=0
  local max_allowed_width=30  # Maximum width for item display (reduced for better fit)
  
  for i in "${!items[@]}"; do
    local item_data="${items[$i]}"
    local name="${item_data%%|*}"
    local status_marker=" (installed)"  # Always account for max status length
    # Calculate: cursor/space (2) + checkbox (3) + space (1) + name + status
    local item_len=$(( 2 + 3 + 1 + ${#name} + ${#status_marker} ))
    if (( item_len > max_name_len )); then
      max_name_len=$item_len
    fi
  done
  
  # Use the calculated width, but cap it at max_allowed_width to prevent wrapping
  if (( max_name_len > max_allowed_width )); then
    max_name_len=$max_allowed_width
  fi
  
  # Column width: use the calculated max, ensure it's at least a minimum
  local min_col_width=25
  if (( max_name_len < min_col_width )); then
    max_name_len=$min_col_width
  fi
  local col_width=$max_name_len
  
  # Calculate minimum terminal width needed (4 columns + padding)
  # This needs to be available to redraw_screen, so define it early
  local min_terminal_width=$((col_width * num_cols + 4))  # 4 for item row padding
  
  # Function to get terminal width
  get_terminal_width() {
    local width
    width=$(tput cols 2>/dev/null || echo 80)
    echo "$width"
  }
  
  # Function to strip ANSI escape codes and get visible length
  # ANSI codes don't take up visual space but are counted in ${#string}
  strip_ansi() {
    # Remove ANSI escape sequences (ESC[ ... m)
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g'
  }
  
  # Function to get visible width (without ANSI codes)
  visible_width() {
    local stripped
    stripped=$(strip_ansi "$1")
    echo ${#stripped}
  }
  
  # Function to get item index from column/row position
  get_item_index() {
    local col=$1
    local row=$2
    echo $((page_start + col * num_rows + row))
  }
  
  # Function to get item display string (returns plain text for width calculation)
  get_item_display_plain() {
    local name="$1"
    local is_selected="$2"
    local is_installed="$3"
    local is_cursor="$4"
    
    local checkbox="[ ]"
    if (( is_selected )); then
      checkbox="[√]"
    fi
    
    local status_marker=""
    if (( is_installed )); then
      status_marker=" (installed)"
    fi
    
    # Calculate available width for the name
    # Account for: cursor (2 chars) or spaces (2 chars) + checkbox (3 chars) + space (1 char) + status
    local prefix_len=6  # "▶ [√] " or "  [ ] " (6 chars including space after checkbox)
    local status_len=${#status_marker}
    # Use col_width instead of max_allowed_width for consistency
    local max_name_display_len=$((col_width - prefix_len - status_len))
    
    # Truncate name if it's too long
    local display_name="$name"
    if (( ${#name} > max_name_display_len )); then
      display_name="${name:0:$((max_name_display_len - 3))}..."
    fi
    
    if (( is_cursor )); then
      echo "▶ ${checkbox} ${display_name}${status_marker}"
    else
      echo "  ${checkbox} ${display_name}${status_marker}"
    fi
  }
  
  # Function to get item display string with colors
  get_item_display() {
    local col=$1
    local row=$2
    local idx=$(get_item_index $col $row)
    local is_cursor=$3  # 1 if this is the cursor position, 0 otherwise
    
    if (( idx >= total )); then
      echo ""
      return
    fi
    
    # Get item data
    local item_idx=0
    local item_data=""
    for i in "${!items[@]}"; do
      if (( item_idx == idx )); then
        item_data="${items[$i]}"
        break
      fi
      ((item_idx++))
    done
    
    if [[ -z "$item_data" ]]; then
      echo ""
      return
    fi
    
    local name="${item_data%%|*}"
    local is_selected=0
    if (( selected["$name"] == 1 )); then
      is_selected=1
    fi
    
    local is_installed=0
    if [[ "$item_data" == *"|installed" ]]; then
      is_installed=1
    fi
    
    local checkbox="[ ]"
    if (( is_selected )); then
      checkbox="[√]"
    fi
    
    local status_marker=""
    if (( is_installed )); then
      status_marker=" (installed)"
    fi
    
    # Calculate available width for the name
    local prefix_len=5  # "▶ [√] " or "  [ ] "
    local status_len=${#status_marker}
    local max_name_display_len=$((max_allowed_width - prefix_len - status_len))
    
    # Truncate name if it's too long
    local display_name="$name"
    if (( ${#name} > max_name_display_len )); then
      display_name="${name:0:$((max_name_display_len - 3))}..."
    fi
    
    # Apply colors based on state
    local checkbox_color=""
    local name_color=""
    local status_color=""
    
    if (( is_selected )); then
      checkbox_color="${color_green}"
      name_color="${color_bold}${color_green}"
    else
      checkbox_color="${color_white}"
      name_color="${color_white}"
    fi
    
    if (( is_installed )); then
      status_color="${color_yellow}"
    fi
    
    if (( is_cursor )); then
      # Cursor: use reverse video for emphasis
      printf "${color_reverse}▶${color_reset} ${checkbox_color}%s${color_reset} ${name_color}%s${color_reset}${status_color}%s${color_reset}" \
        "$checkbox" "$display_name" "$status_marker"
    else
      printf "  ${checkbox_color}%s${color_reset} ${name_color}%s${color_reset}${status_color}%s${color_reset}" \
        "$checkbox" "$display_name" "$status_marker"
    fi
  }
  
  # Function to build a row's content (returns the line string)
  build_row_content() {
    local row=$1
    local cursor_col_pos=$2
    local cursor_row_pos=$3
    
    # Build the line - simpler approach: build each column separately
    local col=0
    local output=""
    
    while (( col < num_cols )); do
      local is_cursor=0
      if (( col == cursor_col_pos && row == cursor_row_pos )); then
        is_cursor=1
      fi
      
      local idx=$(get_item_index $col $row)
      if (( idx < total )); then
        # Get item data
        local item_idx=0
        local item_data=""
        for i in "${!items[@]}"; do
          if (( item_idx == idx )); then
            item_data="${items[$i]}"
            break
          fi
          ((item_idx++))
        done
        
        if [[ -n "$item_data" ]]; then
          local name="${item_data%%|*}"
          local is_selected=0
          if (( selected["$name"] == 1 )); then
            is_selected=1
          fi
          
          local is_installed=0
          if [[ "$item_data" == *"|installed" ]]; then
            is_installed=1
          fi
          
          # Get plain text version for width calculation
          local plain_text
          plain_text=$(get_item_display_plain "$name" $is_selected $is_installed $is_cursor)
          local plain_len=${#plain_text}
          
          # Get colored version for display
          local item_str
          item_str=$(get_item_display $col $row $is_cursor)
          
          # Calculate padding needed (using plain text length)
          local padding=$((col_width - plain_len))
          
          # Build this column's output: item + padding
          if (( padding > 0 )); then
            output="${output}${item_str}$(printf '%*s' "$padding" '')"
          else
            output="${output}${item_str}"
          fi
        else
          # Empty cell - just spaces
          output="${output}$(printf '%*s' "$col_width" '')"
        fi
      else
        # Empty cell (beyond total items)
        output="${output}$(printf '%*s' "$col_width" '')"
      fi
      
      # Add space between columns (except after last column)
      if (( col < num_cols - 1 )); then
        output="${output} "
      fi
      
      ((col++))
    done
    
    # Return the line (no trimming - we control the width exactly)
    echo "$output"
  }
  
  # Function to update a single row (for full redraw)
  update_row() {
    local row=$1
    local line_content=$(build_row_content $row $cursor_col $cursor_row)
    printf "%s" "$line_content" > /dev/tty
  }
  
  # Function to redraw the screen (full or incremental)
  redraw_screen() {
    # Check terminal width and warn if too narrow
    # Note: min_terminal_width is defined in the parent scope
    local term_width
    term_width=$(get_terminal_width)
    # Use default if min_terminal_width isn't set (shouldn't happen, but safety check)
    local min_width=${min_terminal_width:-80}
    if (( term_width < min_width )); then
      # Terminal is too narrow, but we'll still try to display
      # The fixed column width should prevent wrapping
      :
    fi
    
    if (( needs_full_redraw )) || (( page_start != prev_page_start )); then
      # Full redraw - clear screen and start from top
      tput clear > /dev/tty 2>/dev/null || clear > /dev/tty
      
      # Title
      local title=""
      if [[ "$type" == "cask" ]]; then
        title="Select Homebrew Casks to Install"
      elif [[ "$type" == "formula" ]]; then
        title="Select Homebrew Formulae to Install"
      fi
      printf "\n${color_bold}${color_cyan}%s${color_reset}\n" "$title" > /dev/tty
      
      # Count selected
      local selected_count=0
      for name in "${!selected[@]}"; do
        if (( selected["$name"] == 1 )); then
          ((selected_count++))
        fi
      done
      
      local page_end=$((page_start + items_per_page))
      if (( page_end > total )); then
        page_end=$total
      fi
      
      # Stats line
      printf "${color_cyan}Selected: ${color_green}$selected_count${color_reset}/${color_white}$total${color_reset}  |  Showing: ${color_white}$((page_start+1))-$page_end${color_reset} of $total\n\n" > /dev/tty
      
      # Display all items - ensure each line is properly formatted
      local row=0
      while (( row < num_rows )); do
        local line_content
        line_content=$(build_row_content $row $cursor_col $cursor_row)
        # Print the line and clear to end of line
        printf "%s" "$line_content" > /dev/tty
        tput el > /dev/tty 2>/dev/null || true
        printf "\n" > /dev/tty
        ((row++))
      done
      
      # Controls line
      printf "\n${color_cyan}↑/↓${color_reset}: Navigate column  |  ${color_cyan}←/→${color_reset}: Navigate row  |  ${color_green}Space${color_reset}: Toggle  |  ${color_green}d${color_reset}: Done  |  ${color_yellow}a${color_reset}: All  |  ${color_yellow}n${color_reset}: None  |  ${color_red}q${color_reset}: Quit\n" > /dev/tty
      
      needs_full_redraw=0
      prev_page_start=$page_start
      header_lines=3  # Title + stats + blank line
    else
      # Incremental update: only update the rows that changed
      if (( prev_cursor_row != cursor_row || prev_cursor_col != cursor_col )); then
        # Update previous cursor position (removes cursor indicator)
        if (( prev_cursor_row < num_rows )); then
          local line_num=$((header_lines + prev_cursor_row + 1))
          if tput cup $line_num 0 > /dev/tty 2>/dev/null; then
            tput el > /dev/tty 2>/dev/null
            local line_content
            line_content=$(build_row_content $prev_cursor_row $prev_cursor_col $prev_cursor_row)
            printf "%s" "$line_content" > /dev/tty
            tput el > /dev/tty 2>/dev/null
          fi
        fi
        # Update new cursor position (adds cursor indicator)
        if (( cursor_row < num_rows )); then
          local line_num=$((header_lines + cursor_row + 1))
          if tput cup $line_num 0 > /dev/tty 2>/dev/null; then
            tput el > /dev/tty 2>/dev/null
            local line_content
            line_content=$(build_row_content $cursor_row $cursor_col $cursor_row)
            printf "%s" "$line_content" > /dev/tty
            tput el > /dev/tty 2>/dev/null
          fi
        fi
      fi
    fi
    
    # Save current cursor position
    prev_cursor_col=$cursor_col
    prev_cursor_row=$cursor_row
  }
  
  # Initial draw
  redraw_screen
  
  while true; do
    # Check if we should exit before reading
    if (( done )); then
      break
    fi
    
    # Read keypress
    local key
    key=$(read_key)
    
    # Handle empty/timeout - redraw to keep screen fresh
    if [[ -z "$key" ]]; then
      continue
    fi
    
    case "$key" in
      UP)
        # Move up within the same column
        if (( cursor_row > 0 )); then
          ((cursor_row--))
        elif (( page_start > 0 )); then
          # Scroll page up
          page_start=$((page_start - num_cols))
          if (( page_start < 0 )); then
            page_start=0
          fi
          needs_full_redraw=1
        fi
        redraw_screen
        ;;
      DOWN)
        # Move down within the same column
        local current_idx=$(get_item_index $cursor_col $cursor_row)
        local next_idx=$(get_item_index $cursor_col $((cursor_row + 1)))
        if (( next_idx < total )); then
          if (( cursor_row < num_rows - 1 )); then
            ((cursor_row++))
          elif (( page_start + items_per_page < total )); then
            # Scroll page down
            page_start=$((page_start + num_cols))
            needs_full_redraw=1
          fi
        fi
        redraw_screen
        ;;
      LEFT)
        # Move to previous column (same row)
        if (( cursor_col > 0 )); then
          ((cursor_col--))
          redraw_screen
        fi
        ;;
      RIGHT)
        # Move to next column (same row)
        local current_idx=$(get_item_index $cursor_col $cursor_row)
        local next_idx=$(get_item_index $((cursor_col + 1)) $cursor_row)
        if (( next_idx < total && cursor_col < num_cols - 1 )); then
          ((cursor_col++))
          redraw_screen
        fi
        ;;
      SPACE)
        # Toggle selection for current item
        local idx=$(get_item_index $cursor_col $cursor_row)
        if (( idx < total )); then
          local item_idx=0
          for i in "${!items[@]}"; do
            if (( item_idx == idx )); then
              local item_data="${items[$i]}"
              local name="${item_data%%|*}"
              # Toggle selection
              if (( selected["$name"] == 1 )); then
                selected["$name"]=0
              else
                selected["$name"]=1
              fi
              # Update just this row
              local line_num=$((header_lines + cursor_row + 1))
              if tput cup $line_num 0 > /dev/tty 2>/dev/null; then
                tput el > /dev/tty 2>/dev/null
                local line_content
                line_content=$(build_row_content $cursor_row $cursor_col $cursor_row)
                printf "%s" "$line_content" > /dev/tty
                tput el > /dev/tty 2>/dev/null
              fi
              break
            fi
            ((item_idx++))
          done
        fi
        ;;
      ENTER)
        done=1
        ;;
      QUIT)
        # Deselect all and exit
        for name in "${!selected[@]}"; do
          selected["$name"]=0
        done
        done=1
        ;;
      ALL)
        # Select all items
        for name in "${!selected[@]}"; do
          selected["$name"]=1
        done
        needs_full_redraw=1
        redraw_screen
        ;;
      NONE)
        # Deselect all items
        for name in "${!selected[@]}"; do
          selected["$name"]=0
        done
        needs_full_redraw=1
        redraw_screen
        ;;
      *)
        # Ignore other keys
        ;;
    esac
    
    # Check if we should exit after processing the key
    # This must be checked here, not just at the start of the loop
    if (( done )); then
      break
    fi
  done
  
  # Ensure we exit if done was set
  if (( done )); then
    # Already breaking, but ensure cleanup happens
    :
  fi
  
  # Explicitly restore terminal before returning
  # This ensures brew bundle and other commands work properly
  cleanup_terminal
  trap - EXIT INT TERM WINCH
  
  # Double-check terminal is in a normal state
  # Restore saved state explicitly
  if [[ -n "$old_stty" ]]; then
    stty "$old_stty" < /dev/tty 2>/dev/null || true
  fi
  # Ensure echo and canonical mode are definitely restored
  stty echo icanon < /dev/tty 2>/dev/null || true
  # Show cursor
  tput cnorm > /dev/tty 2>/dev/null || true
}

# Install packages from Brewfile
install_brewfile() {
  if [[ ! -f "$BREWFILE" ]]; then
    err "Brewfile not found: $BREWFILE"
    return 1
  fi

  if ! ensure_brew_path; then
    return 1
  fi

  log "Installing packages from Brewfile..."

  if (( DRY_RUN )); then
    dry "Would run: brew bundle --file=\"$BREWFILE\""
    log "Brewfile contains:"
    grep -E "^(brew|cask|tap)" "$BREWFILE" | wc -l | xargs echo "  - Packages/casks:"
    return 0
  fi

  # Parse Brewfile and collect items
  local temp_brewfile
  temp_brewfile=$(mktemp /tmp/mrk2-brewfile.XXXXXX)
  trap "rm -f '$temp_brewfile'" EXIT

  local formulae_count=0
  local casks_count=0
  
  # Arrays to store items for selection
  local -a formula_items=()
  local -a cask_items=()
  # Associative arrays for selected items
  declare -A selected_formulae=()
  declare -A selected_casks=()
  # Map names to their Brewfile lines
  declare -A formula_lines=()
  declare -A cask_lines=()

  # First pass: collect all items and check installation status
  log "Scanning Brewfile for packages... (this may take a moment, please be patient)"
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Copy taps, comments, and blank lines directly
    if [[ "$line" =~ ^tap\  ]] || [[ "$line" =~ ^# ]] || [[ -z "$line" ]]; then
      echo "$line" >> "$temp_brewfile"
      continue
    fi

    # Handle formulae (now interactive like casks)
    if [[ "$line" =~ ^brew\ \"([^\"]+)\" ]]; then
      local formula="${BASH_REMATCH[1]}"
      ((formulae_count++))
      
      if (( NO_FORMULAE )); then
        continue
      fi

      # Check if already installed (but still add to selection list)
      local already_installed=0
      if brew list "$formula" >/dev/null 2>&1; then
        already_installed=1
      fi

      # Add to selection list (even if already installed, so user can see all options)
      # Use same format as casks: "name|line|installed" or "name|line|"
      if (( already_installed )); then
        formula_items+=("$formula|$line|installed")
      else
        formula_items+=("$formula|$line|")
      fi
      formula_lines["$formula"]="$line"
      continue
    fi

    # Handle casks
    if [[ "$line" =~ ^cask\ \"([^\"]+)\" ]]; then
      local cask="${BASH_REMATCH[1]}"
      ((casks_count++))
      
      if (( NO_CASKS )); then
        continue
      fi

      # Check if already installed (but still add to selection list)
      local already_installed=0
      if brew list --cask "$cask" >/dev/null 2>&1; then
        already_installed=1
      fi

      # Add to selection list (even if already installed, so user can see all options)
      if (( already_installed )); then
        cask_items+=("$cask|$line|installed")
      else
        cask_items+=("$cask|$line|")
      fi
      cask_lines["$cask"]="$line"
      continue
    fi

    # Skip MAS apps (Mac App Store support removed due to reliability issues)
    if [[ "$line" =~ ^mas[[:space:]] ]]; then
      continue
    fi

    # Copy any other lines we don't recognize (for future compatibility)
    echo "$line" >> "$temp_brewfile"
  done < "$BREWFILE"

  log "Found: ${#formula_items[@]} formulae to select, ${#cask_items[@]} casks to select"

  # Show interactive selection for formulae
  if (( ${#formula_items[@]} > 0 )) && (( ! NO_FORMULAE )); then
    interactive_selection "formula" formula_items selected_formulae
    
    # Add selected formulae to temp Brewfile (skip already installed ones)
    local selected_count=0
    for name in "${!selected_formulae[@]}"; do
      if (( selected_formulae["$name"] == 1 )); then
        # Check if already installed - skip if so
        if brew list "$name" >/dev/null 2>&1; then
          log "Formula '$name' is already installed, skipping installation"
          continue
        fi
        echo "${formula_lines[$name]}" >> "$temp_brewfile"
        ((selected_count++))
      fi
    done
    FORMULAE_INSTALLED=$selected_count
    log "Selected $selected_count/${#formula_items[@]} formulae for installation"
  elif (( NO_FORMULAE )); then
    FORMULAE_INSTALLED=0
    log "Skipped ${#formula_items[@]} formulae (--no-formulae flag)"
  else
    FORMULAE_INSTALLED=0
  fi

  # Show interactive selection for casks
  if (( ${#cask_items[@]} > 0 )) && (( ! NO_CASKS )); then
    interactive_selection "cask" cask_items selected_casks
    
    # Add selected casks to temp Brewfile (skip already installed ones)
    local selected_count=0
    for name in "${!selected_casks[@]}"; do
      if (( selected_casks["$name"] == 1 )); then
        # Check if already installed - skip if so
        if brew list --cask "$name" >/dev/null 2>&1; then
          log "Cask '$name' is already installed, skipping installation"
          continue
        fi
        echo "${cask_lines[$name]}" >> "$temp_brewfile"
        ((selected_count++))
      fi
    done
    CASKS_INSTALLED=$selected_count
    log "Selected $selected_count/${#cask_items[@]} casks for installation"
  fi

  # Install from temporary Brewfile
  # Ensure terminal is in normal state before running brew bundle
  # (in case it's still in raw mode from interactive selection)
  stty echo icanon < /dev/tty 2>/dev/null || true
  tput cnorm > /dev/tty 2>/dev/null || true
  
  log "Installing selected packages..."
  
  # Ensure stdin is from terminal for any prompts brew bundle might need
  # The exec redirections handle stdout/stderr logging, but we need to ensure
  # brew bundle can read from the terminal if it needs to prompt
  # Use a subshell to ensure proper file descriptor handling
  local bundle_exit=0
  (
    # Ensure stdin is from terminal
    exec < /dev/tty
    # Run brew bundle - output will go through the exec redirections
    brew bundle --file="$temp_brewfile" --verbose
  ) || bundle_exit=$?
  
  # Flush any pending output to ensure tee processes complete
  # This prevents hanging after brew bundle finishes
  exec >&-
  exec 2>&-
  sleep 0.1
  exec > >(tee -a "$LOGFILE")
  exec 2> >(tee -a "$LOGFILE" >&2)
  
  if (( bundle_exit == 0 )); then
    log "Brewfile installation completed successfully"
    return 0
  else
    err "Brewfile installation failed (exit code: $bundle_exit)"
    ((ERRORS++))
    return 1
  fi
}

# Main installation flow
main() {
  log "Starting mrk2 installation process..."

  # Phase 1: Install Homebrew
  if ! install_homebrew; then
    err "Failed to install Homebrew. Aborting."
    exit 1
  fi

  # Ensure Homebrew is in PATH
  if ! ensure_brew_path; then
    err "Homebrew is not available. Aborting."
    exit 1
  fi

  # Phase 2: Install from Brewfile
  if ! install_brewfile; then
    err "Failed to install packages from Brewfile"
    ((ERRORS++))
  fi

  # Installation summary
  show_summary
}

show_summary() {
  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo "  Installation Summary"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  
  if (( DRY_RUN )); then
    echo "  Mode: DRY RUN (no changes were made)"
    echo ""
  fi
  
  if (( BREW_INSTALLED > 0 )); then
    echo "  ✓ Homebrew installed"
  fi
  
  if (( FORMULAE_INSTALLED > 0 )); then
    echo "  ✓ Formulae installed: ~$FORMULAE_INSTALLED"
  fi
  
  if (( CASKS_INSTALLED > 0 )); then
    echo "  ✓ Casks installed: ~$CASKS_INSTALLED"
  fi
  
  if (( ERRORS > 0 )); then
    echo "  ✗ Errors encountered: $ERRORS"
  fi
  
  if (( WARNINGS > 0 )); then
    echo "  ⚠ Warnings: $WARNINGS"
  fi
  
  echo ""
  echo "  Log file: $LOGFILE"
  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
}

if (( ! DRY_RUN )); then
  main
  if (( ERRORS > 0 )); then
    log "Installation completed with errors. Check the log: $LOGFILE"
    exit 1
  else
    log "Installation complete."
  fi
else
  main
  echo ""
  log "Dry run complete. No changes were made."
  echo "Run without --dry-run to apply changes."
fi

